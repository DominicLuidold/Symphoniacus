package at.fhv.orchestraria.domain.model;

import at.fhv.orchestraria.domain.Imodel.*;
import at.fhv.orchestraria.domain.integrationInterfaces.IntegratableDutyPosition;
import at.fhv.orchestraria.domain.integrationInterfaces.IntegratableMusician;

import javax.persistence.*;
import java.io.Serializable;
import java.time.LocalDate;
import java.util.*;

/**
 * @author generated by Intellij -  edited by Team C
 */

@Entity
@Table(name = "musician", schema = "ni128610_1sql8")
public class MusicianEntityC implements IMusician, IntegratableMusician, Serializable {

    public static final String SECTION_PRINCIPAL_NAME= "Stimmfuehrer";
    public static final String DUTY_SCHEDULER_NAME = "Diensteinteiler";
    public static final String DEFAULT_MUSICIAN_ROLE = "Tutti-Spieler";

    public static final int EXTERNAL_MUSICIAN_ID = 99999999;

    private int musicianId;
    private Collection<ContractualObligationEntityC> contractualObligations;
    private Collection<DutyPositionEntityC> dutyPositions;
    private Collection<InstrumentCategoryMusicianEntityC> instrumentCategoryMusicians;
    private UserEntityC user;
    private SectionEntityC section;
    private Collection<MusicianRoleMusicianEntityC> musicianRoleMusicians;
    private Collection<NegativeDateWishEntityC> negativeDateWishes;
    private Collection<NegativeDutyWishEntityC> negativeDutyWishes;
    private Collection<PositiveWishEntityC> positiveWishes;
    private Collection<SubstituteEntityC> substitutes;
    private Collection<VacationEntityC> vacations;


    /*
     *Methods created by Team C
     */

    @Override
    @Transient
    public boolean isDutyScheduler(){
        for(MusicianRoleMusicianEntityC role : musicianRoleMusicians){
            if(role.getMusicianRole().getDescription().equals(DUTY_SCHEDULER_NAME)){
                return true;
            }
        }
        return false;
    }

    @Override
    @Transient
    public boolean hasReachedMaxAmountOfEveningDutiesOnMonth(LocalDate date){
        return getMaxAmountOfEveningDuties() <= getCountOfEveningDutiesOfMonth(date);
    }

    @Override
    @Transient
    public int getMaxAmountOfEveningDuties(){
        int maxAmountOfEveningDuties = 17;
        for(MusicianRoleMusicianEntityC role : getMusicianRoleMusicians()){
            if (role.getMusicianRole().getDescription().equals(SECTION_PRINCIPAL_NAME)) {
                maxAmountOfEveningDuties = 15;
                break;
            }
        }
        return maxAmountOfEveningDuties;
    }

    @Override
    @Transient
    public boolean hasBeenAssignedToMaxAmountOfDutiesOnDate(LocalDate date){
        boolean hasBeenAssignedToTheMax = false;
        if(section.isBrassSection()){
            int assignedEveningDuties = 0;
            HashSet<DutyEntityC> closedList = new HashSet<>();

            for(DutyPositionEntityC dpe: dutyPositions){
                DutyEntityC assignedToDuty= dpe.getDuty();
                if(!closedList.contains(assignedToDuty)
                        && assignedToDuty.getStart().getYear() == date.getYear()
                        && assignedToDuty.getStart().getDayOfYear() == date.getDayOfYear()) {
                    closedList.add(assignedToDuty);
                    assignedEveningDuties++;
                }
            }
            if(assignedEveningDuties>=2){
                hasBeenAssignedToTheMax =true;
            }
        }
        return hasBeenAssignedToTheMax;
    }


//    /**
//     * Takes a List of DutyPositionEntities and checks them all (O(nÂ²)) if they are from the sam eduty or not and counts
//     * the unique ones.
//     * @param uniqueDPEs List of DutyPositionEntities. Try to make this as short as possible before invoking this method
//     * @return returns the amount of DutyPositionEntites that have unique Duties
//     */
//    private int getAmountOfDutyPositionsWithUniqueDuties(ArrayList<DutyPositionEntity> uniqueDPEs) {
//        for(int i = 0; i<uniqueDPEs.size(); i++){
//            int removed = 0;
//            for(int j = 0; j<uniqueDPEs.size(); j++){
//                if(uniqueDPEs.get(i).getDuty().equals(uniqueDPEs.get(j).getDuty()) && !uniqueDPEs.get(i).equals(uniqueDPEs.get(j))){
//                    uniqueDPEs.remove(i);
//                    j--;
//                    removed++;
//                }
//            }
//            i = i-removed;
//            //TODO: Testme with multiple instrumentations in 1 duty //Maybe use hashmaps for better performance?
//        }
//        return uniqueDPEs.size();
//    }


    /**
     * Iterates all positive wishes of the musician and checks if there is one corresponding to the provided duty.
     * @param duty The duty the positive wish would refer to to.
     * @return Returns an optional that contains either the wish or is empty in case there is no wish.
     */
    @Override
    @Transient
    public Optional<IPositiveWish> getPositiveWish(IDuty duty) {
        for (IPositiveWish wish : positiveWishes) {
            if (wish.getSeriesOfPerformances().equals(duty.getSeriesOfPerformances())) {
                return Optional.of(wish);
            }
        }
        return Optional.empty();
    }

    /**
     * Iterates all negative duty wishes of the musician and checks if there is one corresponding to the provided duty.
     * @param duty The duty the negative duty wish would refer to to.
     * @return Returns an optional that contains either the wish or is empty in case there is no wish.
     */
    @Override
    @Transient
    public Optional<INegativeDutyWish> getNegativeDutyWish(IDuty duty) {
        for (INegativeDutyWish wish : negativeDutyWishes) {
            if (wish.getSeriesOfPerformances().equals(duty.getSeriesOfPerformances())) {
                return Optional.of(wish);
            }
        }
        return Optional.empty();
    }

    /**
     * Iterates all negative date wishes of the musician and checks if there is one corresponding to the provided duty.
     * @param duty The duty in which timespan the negative date wish may be in.
     * @return Returns an optional that contains either the wish or is empty in case there is no wish.
     */
    @Override
    @Transient
    public Optional<INegativeDateWish> getNegativeDateWish(IDuty duty) {
        if (duty.getSeriesOfPerformances()!=null && duty.getSeriesOfPerformances().isTour()) {
            for (INegativeDateWish wish : negativeDateWishes) {
                if (wish.getStartDate().isBefore(duty.getSeriesOfPerformances().getEndDate()) && wish.getEndDate().isAfter(duty.getSeriesOfPerformances().getStartDate())) {
                    return Optional.of(wish);
                }
            }
        }else {
            for (INegativeDateWish wish : negativeDateWishes) {
                if (wish.getStartDate().isEqual(duty.getEnd().toLocalDate()) && wish.getEndDate().isEqual(duty.getStart().toLocalDate())) {
                    return Optional.of(wish);
                }
            }
        }
        return Optional.empty();
    }

    /*
     *Methods created by Team C
     */
    @Override
    @Transient
    public int getCountOfEveningDutiesOfMonth(LocalDate date) {
        int eveningDutyCount = 0;

//        ArrayList<DutyPositionEntity> uniqueDPEs = new ArrayList<>();
//        uniqueDPEs.addAll(dutyPositions);
//
//        for(int i = 0; i<uniqueDPEs.size(); i++){
//            IDuty assignedToDuty = uniqueDPEs.get(i).getDuty();
//            if (assignedToDuty.getStart().getMonth() != date.getMonth() &&
//                    assignedToDuty.getStart().getYear() != date.getYear() &&
//                    !assignedToDuty.getTimeOfDay().equals(DutyEntity.EVENING_DUTY_NAME)) {
//                uniqueDPEs.remove(i);
//                i--;
//            }
//        }

        HashSet<DutyEntityC> closedList = new HashSet<>();

        for(DutyPositionEntityC dpe: dutyPositions){
            DutyEntityC assignedToDuty= dpe.getDuty();
            if(!closedList.contains(assignedToDuty)
                && assignedToDuty.getStart().getMonth() == date.getMonth() &&
                    assignedToDuty.getStart().getYear() == date.getYear() &&
                    assignedToDuty.getTimeOfDay().equals(DutyEntityC.EVENING_DUTY_NAME)) {

                closedList.add(dpe.getDuty());
                eveningDutyCount++;
            }
        }
        return eveningDutyCount;
    }

    /**
     * Calculates the amount of points the musician is assigned for in the month of the date.
     * @param date A date in the month the request is referring to.
     * @return Amount of points the musician is assigned for in the month of the date.
     */
    @Override
    @Transient
    public int getRequiredPointsOfMonth(LocalDate date) {
        for (ContractualObligationEntityC coa : contractualObligations) {
            if (date.isBefore(coa.getEndDate()) && date.isAfter(coa.getStartDate())) {
                return coa.getPointsPerMonth();
            }
        }
        return 0;
    }


    /**
     * Calculates the amount of points the musician is required to have in the month of the date.
     * @param date A date in the month the request is referring to.
     * @return Amount of points the musician is required to have in the month of the date
     */
    @Override
    @Transient
    public int getPointsOfMonth(LocalDate date) { //TODO add check for multipleduty-assignement
        int collectedPoints = 0;
//            ArrayList<DutyPositionEntity> uniqueDPEs = new ArrayList<>();
//            uniqueDPEs.addAll(dutyPositions);

//            for(int i = 0; i<uniqueDPEs.size(); i++) {
//                if (uniqueDPEs.get(i).getDuty().getStart().getMonth() == date.getMonth() &&
//                        uniqueDPEs.get(i).getDuty().getStart().getYear() == date.getYear()
//                        && uniqueDPEs.get(i).getDuty().getDutyCategory() != null) {}
//                else {
//                    uniqueDPEs.remove(i);
//                    i--;
//                }
//            }
//
//        for(int i = 0; i<uniqueDPEs.size(); i++){
//            int removed = 0;
//            for(int j = 0; j<uniqueDPEs.size(); j++){
//                if(uniqueDPEs.get(i).getDuty().equals(uniqueDPEs.get(j).getDuty()) && !uniqueDPEs.get(i).equals(uniqueDPEs.get(j))){
//                    uniqueDPEs.remove(i);
//                    j--;
//                    removed++;
//                }
//            }
//            i = i-removed;
//            //TODO: Testme with multiple instrumentations in 1 duty //Maybe use hashmaps for better performance?
//        }
//        for (DutyPositionEntity dutyPosMus : uniqueDPEs) {
//                collectedPoints += dutyPosMus.getDuty().getDutyCategory().getPoints();
//        }


        HashSet<DutyEntityC> closedList = new HashSet<>();

        for(DutyPositionEntityC dpe: dutyPositions){
            DutyEntityC assignedToDuty= dpe.getDuty();
            if(!closedList.contains(assignedToDuty)
                    && assignedToDuty.getStart().getMonth() == date.getMonth()
                    && assignedToDuty.getStart().getYear() == date.getYear()){
                closedList.add(assignedToDuty);
                collectedPoints+=assignedToDuty.getDutyCategory().getPoints();
            }
        }


        return collectedPoints;
    }

    /**
     * Checks if the musician is on tour, on vacation or on an other event on the delivered duty.
     * @param duty: Specified duty
     * @return True if musician is available on that day
     */
    @Override
    @Transient
    public boolean isAvailableAtDuty(IDuty duty) {
        if(musicianId == EXTERNAL_MUSICIAN_ID) return true;
        return !isOnEventAtDate(duty) && !isOnVacationAtDate(duty.getStart().toLocalDate())
                   && !isOnTourAtDate(duty);
    }


    /**
     * Iterates all the events the musician is assigned to and looks if any of those are in the same timespan as the provided timestamp.
     * @param providedDuty The duty where the musician may be assigned for an event.
     * @return Returns true if musician has other event at that point in time.
     */
    @Transient
    @Override
    public boolean isOnEventAtDate(IDuty providedDuty) {
        for (DutyPositionEntityC dutyPosition : dutyPositions) {
            DutyEntityC duty = dutyPosition.getDuty();
            if (!duty.equals(providedDuty) && providedDuty.getEnd().isAfter(duty.getStart()) && providedDuty.getStart().isBefore(duty.getEnd())) {
                return true;
            }
        }
        return false;
    }

    /**
     * Iterates all the duties the musician is assigned to and looks any tour is in the same timespan as the provided timestamp.
     * @param duty The duty at which date the musician may be on tour.
     * @return Returns true if a musician is assigned for a tour at that point in time.
     */
    @Transient
    @Override
    public boolean isOnTourAtDate(IDuty duty) {
        LocalDate date = duty.getStart().toLocalDate();
        for (DutyPositionEntityC dpme : dutyPositions) {
            SeriesOfPerformancesEntityC seriesOfPerformance = dpme.getDuty().
                    getSeriesOfPerformances();
            if (seriesOfPerformance != null && !seriesOfPerformance.equals(duty.getSeriesOfPerformances()) && seriesOfPerformance.isTour()) {
                if (date.isBefore(seriesOfPerformance.getEndDate().plusDays(1)) && date.isAfter(seriesOfPerformance.getStartDate().minusDays(1))) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Iterates all the vacations the musician has registered  and looks if any of those are in the same timespan as the provided timestamp.
     * @param date The timestamp where musician may be on vacation.
     * @return Returns true if a musician registered a vacation at that point in time.
     */
    @Transient
    @Override
    public boolean isOnVacationAtDate(LocalDate date) {
        for (VacationEntityC ve : vacations) {
            if (date.isBefore(ve.getEndDate().toLocalDate().plusDays(1)) && date.isAfter(ve.getStartDate().toLocalDate().minusDays(1))) {
                return true;
            }
        }
        return false;
    }

    /**
     * Checks if the musician can play the provided instrument.
     * @param instrumentName The abbreviation of the instrument category as used in the section definitions.
     * @return Returns true if the musician can play the instrument.
     */
    @Override
    @Transient
    public boolean canPlayInstrument(String instrumentName) {
        for (InstrumentCategoryMusicianEntityC instrument : instrumentCategoryMusicians) {
            if (instrumentName.equals(instrument.getInstrumentCategory().getDescription())) {
                return true;
            }
        }
        return false;
    }


    /**
     * Checks if the musician is a section principal.
     * @return Returns true if the musician is a section principal.
     */
    @Override
    @Transient
    public boolean isSectionPrincipal() {
        for(MusicianRoleMusicianEntityC roles : musicianRoleMusicians){
            if(roles.getMusicianRole().getDescription().equals(SECTION_PRINCIPAL_NAME)){
                return true;
            }
        }
        return false;
    }


    /*
     * Generated by IntelliJ
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "musicianId")
    @Override
    public int getMusicianId() {
        return musicianId;
    }

    public void setMusicianId(int musicianId) {
        this.musicianId = musicianId;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        MusicianEntityC that = (MusicianEntityC) o;
        return musicianId == that.musicianId;
    }

    @Override
    public int hashCode() {
        return Objects.hash(musicianId);
    }

    @OneToMany(mappedBy = "musician", cascade = CascadeType.MERGE)
    public Collection<ContractualObligationEntityC> getContractualObligations() {
        return contractualObligations;
    }

    public void setContractualObligations(Collection<ContractualObligationEntityC> contractualObligationsByMusicianId) {
        this.contractualObligations = contractualObligationsByMusicianId;
    }

    @OneToMany(mappedBy = "musician", cascade = CascadeType.MERGE)
    public Collection<DutyPositionEntityC> getDutyPositions() {
        return dutyPositions;
    }

    public void setDutyPositions(Collection<DutyPositionEntityC> dutyPositionsByMusicianId) {
        this.dutyPositions = dutyPositionsByMusicianId;
    }

    @OneToMany(mappedBy = "musician")
    public Collection<InstrumentCategoryMusicianEntityC> getInstrumentCategoryMusicians() {
        return instrumentCategoryMusicians;
    }

    public void setInstrumentCategoryMusicians(Collection<InstrumentCategoryMusicianEntityC> instrumentCategoryMusiciansByMusicianId) {
        this.instrumentCategoryMusicians = instrumentCategoryMusiciansByMusicianId;
    }

    @OneToOne (cascade = CascadeType.MERGE)
    @JoinColumn(name = "userId", referencedColumnName = "userId", nullable = false )
    @Override
    public UserEntityC getUser() {
        return user;
    }

    public void setUser(UserEntityC user) {
        this.user = user;
    }

    @ManyToOne
    @JoinColumn(name = "sectionId", referencedColumnName = "sectionId")
    @Override
    public SectionEntityC getSection() {
        return section;
    }

    public void setSection(SectionEntityC section) {
        this.section = section;
    }

    @OneToMany(mappedBy = "musician", cascade = CascadeType.MERGE)
    public Collection<MusicianRoleMusicianEntityC> getMusicianRoleMusicians() {
        return musicianRoleMusicians;
    }

    public void setMusicianRoleMusicians(Collection<MusicianRoleMusicianEntityC> musicianRoleMusiciansByMusicianId) {
        this.musicianRoleMusicians = musicianRoleMusiciansByMusicianId;
    }

    @OneToMany(mappedBy = "musician")
    public Collection<NegativeDateWishEntityC> getNegativeDateWishes() {
        return negativeDateWishes;
    }

    public void setNegativeDateWishes(Collection<NegativeDateWishEntityC> negativeDateWishesByMusicianId) {
        this.negativeDateWishes = negativeDateWishesByMusicianId;
    }

    @OneToMany(mappedBy = "musician")
    public Collection<NegativeDutyWishEntityC> getNegativeDutyWishes() {
        return negativeDutyWishes;
    }

    public void setNegativeDutyWishes(Collection<NegativeDutyWishEntityC> negativeDutyWishesByMusicianId) {
        this.negativeDutyWishes = negativeDutyWishesByMusicianId;
    }

    @OneToMany(mappedBy = "musician")
    public Collection<PositiveWishEntityC> getPositiveWishes() {
        return positiveWishes;
    }

    public void setPositiveWishes(Collection<PositiveWishEntityC> positiveWishesByMusicianId) {
        this.positiveWishes = positiveWishesByMusicianId;
    }

    @OneToMany(mappedBy = "musician")
    public Collection<SubstituteEntityC> getSubstitutes() {
        return substitutes;
    }

    public void setSubstitutes(Collection<SubstituteEntityC> substitutesByMusicianId) {
        this.substitutes = substitutesByMusicianId;
    }

    @OneToMany(mappedBy = "musician")
    public Collection<VacationEntityC> getVacations() {
        return vacations;
    }

    public void setVacations(Collection<VacationEntityC> vacationsByMusicianId) {
        this.vacations = vacationsByMusicianId;
    }


    /*
     *Interface methods
     */
    @Transient
    @Override
    public Collection<IContractualObligation> getIContractualObligations() {
        return Collections.unmodifiableCollection(getContractualObligations());
    }

    @Transient
    public Collection<IDutyPosition> getIDutyPositions() {
        return Collections.unmodifiableCollection(getDutyPositions());
    }

    @Transient
    @Override
    public Collection<IntegratableDutyPosition> getIntegratableDutyPositions() {
        return Collections.unmodifiableCollection(getDutyPositions());
    }

    @Transient
    @Override
    public Collection<IInstrumentCategoryMusician> getIInstrumentCategoryMusicians() {
        return Collections.unmodifiableCollection(getInstrumentCategoryMusicians());
    }

    @Transient
    @Override
    public Collection<IMusicianRoleMusician> getIMusicianRoleMusicians() {
        return Collections.unmodifiableCollection(getMusicianRoleMusicians());
    }

    @Transient
    @Override
    public Collection<INegativeDateWish> getINegativeDateWishes() {
        return Collections.unmodifiableCollection(getNegativeDateWishes());
    }

    @Transient
    @Override
    public Collection<INegativeDutyWish> getINegativeDutyWishes() {
        return Collections.unmodifiableCollection(getNegativeDutyWishes());
    }

    @Transient
    @Override
    public Collection<IPositiveWish> getIPositiveWishes() {
        return Collections.unmodifiableCollection(getPositiveWishes());
    }

    @Transient
    @Override
    public Collection<ISubstitute> getISubstitutes() {
        return Collections.unmodifiableCollection(getSubstitutes());
    }

    @Transient
    @Override
    public Collection<IVacation> getIVacations() {
        return Collections.unmodifiableCollection(getVacations());
    }

    @Override
    public String toString(){
        return getUser().getShortcut();
    }
}
